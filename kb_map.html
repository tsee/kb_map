<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>test</title>
        
<script>
</script>
</head>
<body>
<canvas id="board-canvas" width="700px" height="700px"/>
<script>
let canvas_width = 700;
let canvas_height = 700;
let border_width = 10;

let tile_img_width = 400;
let tile_img_height= 346;

let row_size = 10;
let col_size = 10;
let tile_height = (canvas_height - 2*border_width) / col_size;
let tile_width  = (canvas_width  - 2*border_width) / row_size;

var tile_images_loaded = 0;

function TileType (name, path) {
  this.name = name;
  this.path = path;
  this.img = new Image();
  this.img.onload = function(){ ++tile_images_loaded; };
  this.img.src = path;
}

const tile_types = {
  none: new TileType("none", "img/white_with_cross.png"),
  grass: new TileType("grass", "img/green.png"),
  forest: new TileType("forest", "img/dark_green.png"),
  flowers: new TileType("flowers", "img/violet.png"),
  desert: new TileType("desert", "img/yellow.png"),
  canyon: new TileType("canyon", "img/brown.png"),
  water: new TileType("water", "img/blue.png"),
  mountain: new TileType("mountain", "img/dark_gray.png"),
  castle: new TileType("castle", "img/castle.png"),
};

function Tile (col, row, typename) {
  this.col = col; // from 0
  this.row = row; // from 0
  this.canvas_x = 0; // top left corner of tile (to be computed)
  this.canvas_y = 0;
  this.typename = typename;
  update_canvas_pos(this);
}

function update_canvas_pos(tile) {
  // hexagon:
  // height = sqrt(3)*a
  // a = height/sqrt(3)
  //let a = tile_height / Math.sqrt(3);
  tile.canvas_y = border_width + tile.row * tile_height;
  if (tile.col % 2 == 1) {
    tile.canvas_y += tile_height/2
  }

  tile.canvas_x = border_width + (tile_width + tile_height/Math.sqrt(3))/2 * tile.col;
}

function draw_tile(ctx, tile) {
  let tt = tile_types[tile.typename];
  ctx.drawImage(
    tt.img,
    0, 0, // pos in source img
    tile_img_width, tile_img_height, // size of source crop
    tile.canvas_x, tile.canvas_y, // dest in canvas top left
    tile_width, tile_width // size in output
  );
}

let canvas = document.getElementById('board-canvas');
let ctx = canvas.getContext('2d');
let canvas_left = canvas.offsetLeft + canvas.clientLeft;
let canvas_top = canvas.offsetTop + canvas.clientTop

// TODO this is nonsense logic, just undoing the placement of the rectangular sprites.
// Need to do real hexagonal math / coordinate transformation
function find_tile_from_canvas_coordinates(x, y) {
  x -= border_width;
  y -= border_width;
  var col = x / ((tile_width + tile_height/Math.sqrt(3))/2) - 0.5;
  var tile_col = Math.floor(col);
  var row = y;
  if (tile_col % 2 == 1) {
    row -= tile_height / 2;
  }
  row = row / tile_height;
  var tile_row = Math.floor(row);

  console.log("x="+x+" y="+y+" col="+col + " colCoord="+tile_col+" row="+row + " rowCoord="+tile_row); 
  return {col: tile_col, row: tile_row};
}

canvas.addEventListener('click', function(event) {
  let x = event.pageX - canvas_left,
      y = event.pageY - canvas_top;

  let tile_pos = find_tile_from_canvas_coordinates(x, y);

  // this is just for testing
  update_tile_type(tile_pos.col, tile_pos.row, "desert");
}, false);

  // this is just for testing
async function update_tile_type(col, row, type) {
  let resp = await fetch('/board_set?col=' + col + ";row=" + row + ";type=" + type);
}

async function refresh_board() {
  let resp = await fetch('/board');
  let board = await resp.json();
  let tiles = board["tiles"];
  // full clear
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let row = 0; row < col_size; ++row) {
    for (let col = 0; col < row_size; ++col) {
      let i = row * row_size + col;
      draw_tile(ctx, new Tile(col, row, tiles[i]));
    }
  }
  //draw_tile(ctx, new Tile(1, 2, "flowers"));
}

function main_loop () {
  setInterval(function() {
      refresh_board();
    }, 100
  );
}

// wait for all images to be loaded
function wait_images_loaded() {
    if (tile_images_loaded < Object.keys(tile_types).length) {
       window.setTimeout(wait_images_loaded, 100); /* this checks the flag every 100 milliseconds*/
    } else {
      main_loop();
    }
}
wait_images_loaded();

// Create our image
//let newImage = new Image();
//newImage.src = 'img/blue.png'

// When it loads
//newImage.onload = () => {
    // Draw the image onto the context
//    ctx.drawImage(newImage, 0, 0, 25, 25);
//}

</script>

</body>

